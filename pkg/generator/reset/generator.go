// generator.go (полная исправленная версия)
package reset

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
)

type ResetGenerator struct {
	packageInfo []*packageInfo
}

func NewResetGenerator(infos []*packageInfo) ResetGenerator {
	return ResetGenerator{packageInfo: infos}
}

func (r ResetGenerator) GenerateReset() error {
	for _, pkg := range r.packageInfo {
		err := generateResetFile(pkg)
		if err != nil {
			return err
		}
	}
	return nil
}

func generateResetFile(pkgInfo *packageInfo) error {
	var buf bytes.Buffer

	// Заголовок файла
	buf.WriteString("// Code generated by reset. DO NOT EDIT.\n")
	buf.WriteString("package " + pkgInfo.name + "\n\n")

	// Генерируем методы Reset для каждой структуры
	for _, structInfo := range pkgInfo.structs {
		buf.WriteString(generateResetMethod(structInfo))
		buf.WriteString("\n")
	}

	// Форматируем код
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting source: %w", err)
	}

	// Создаем файл reset.gen.go
	outputPath := filepath.Join(pkgInfo.path, "reset.gen.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("writing file %s: %w", outputPath, err)
	}

	fmt.Printf("Generated reset methods for package %s (%s)\n", pkgInfo.name, pkgInfo.path)
	return nil
}

func generateResetMethod(structInfo *structInfo) string {
	var buf bytes.Buffer

	receiverName := strings.ToLower(string(structInfo.name[0]))

	buf.WriteString(fmt.Sprintf("func (%s *%s) Reset() {\n", receiverName, structInfo.name))
	buf.WriteString(fmt.Sprintf("    if %s == nil {\n", receiverName))
	buf.WriteString("        return\n")
	buf.WriteString("    }\n\n")

	for _, field := range structInfo.fields {
		buf.WriteString(generateFieldReset(receiverName, field))
	}

	buf.WriteString("}")

	return buf.String()
}

func generateFieldReset(receiverName string, field *fieldInfo) string {
	var buf bytes.Buffer

	fieldAccess := receiverName + "." + field.name

	switch {
	case field.isPtr:
		buf.WriteString(fmt.Sprintf("    if %s != nil {\n", fieldAccess))

		if field.isStruct {
			// Для указателей на структуры проверяем наличие метода Reset
			buf.WriteString(fmt.Sprintf("        if resetter, ok := interface{}(%s).(interface{ Reset() }); ok {\n", fieldAccess))
			buf.WriteString("            resetter.Reset()\n")
			buf.WriteString("        } else {\n")
			// Если нет метода Reset, сбрасываем значение через разыменование
			buf.WriteString(fmt.Sprintf("            *%s = %s{}\n", fieldAccess, strings.TrimPrefix(field.typeExpr, "*")))
			buf.WriteString("        }\n")
		} else {
			// Для указателей на примитивы сбрасываем значение через разыменование
			// Получаем внутренний тип (без *)
			innerType := strings.TrimPrefix(field.typeExpr, "*")
			buf.WriteString(fmt.Sprintf("        *%s = %s\n", fieldAccess, getZeroValue(innerType)))
		}

		buf.WriteString("    }\n")

	case field.isSlice:
		buf.WriteString(fmt.Sprintf("    %s = %s[:0]\n", fieldAccess, fieldAccess))

	case field.isMap:
		buf.WriteString(fmt.Sprintf("    clear(%s)\n", fieldAccess))

	case field.isStruct:
		// Для вложенных структур проверяем наличие метода Reset
		buf.WriteString(fmt.Sprintf("    if resetter, ok := interface{}(&%s).(interface{ Reset() }); ok {\n", fieldAccess))
		buf.WriteString("        resetter.Reset()\n")
		buf.WriteString("    }\n")

	default:
		// Для примитивных типов
		buf.WriteString(fmt.Sprintf("    %s = %s\n", fieldAccess, getZeroValue(field.typeExpr)))
	}

	return buf.String()
}

func getZeroValue(typeExpr string) string {
	switch typeExpr {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "byte", "rune", "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "complex64", "complex128":
		return "0"
	default:
		return typeExpr + "{}"
	}
}
